* TOC
{:toc}

在 TBMQ 的实现中，支持两种不同类型的客户端：**设备**和**应用程序**。
这种分类基于我们在物联网生态系统中的广泛经验，我们观察到大多数客户端可以归类为这两个主要用例之一。

* 设备客户端主要用于发布大量消息，同时订阅数量有限的主题，消息速率相对较低。这些客户端通常与频繁向 TBMQ 传输数据的物联网设备或传感器相关联。

* 应用程序客户端专门用于订阅消息速率高的主题。当客户端处于脱机状态时，它们通常需要持久化消息以便稍后交付，从而确保关键数据的可用性。应用程序客户端通常用于实时分析、数据处理或其他应用程序级功能。

通过将客户端分类为这些不同的类型，我们可以更好地调整 TBMQ 以适应每个用例的特定要求和性能期望。这种客户端分离简化了不同物联网场景的实现，从而优化了整体系统性能。

客户端类型的确定发生在处理 _CONNECT_ 数据包期间，客户端身份验证在识别客户端类型中起着关键作用。有关客户端身份验证的更多详细信息，请参阅 [安全](/docs/mqtt-broker/security/) 指南，其中提供了有关保护客户端连接的全面信息。

如果禁用基本身份验证和 TLS 身份验证，则连接的客户端将始终被分配为设备类型。但是，当启用基本身份验证或 TLS 身份验证时，客户端类型由身份验证过程中使用的 MQTT 凭据确定。每个 MQTT 客户端凭据都包含一个 `clientType` 字段，该字段明确定义了客户端类型。有关创建 MQTT 凭据的分步说明，请参阅指定的 [指南](/docs/mqtt-broker/user-guide/ui/mqtt-client-credentials/)。

### 客户端持久性

MQTT 客户端发布的所有消息都持久存储在 `tbmq.msg.all` Kafka 主题中。这些消息的后续处理根据客户端类型以及客户端是持久性还是非持久性而有所不同。

{% capture difference %}
要深入了解客户端持久性的详细信息，值得探讨 [Clean Session](https://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718030) 的概念MQTT v3.x 中的属性或 [Clean Start](https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901039) 和 [Session Expiry Interval](https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901048) MQTT v5 中的属性。这些属性在各自的 MQTT 规范中定义，提供了有关客户端会话在持久性方面的行为和处理的见解。
{% endcapture %}
{% include templates/info-banner.md content=difference %}

TBMQ 使用一个 Kafka 消费者，该消费者主动轮询 `tbmq.msg.all` 主题中的消息，然后将这些消息转发给其预期的收件人。但是，持久性客户端和非持久性客户端之间的处理逻辑不同。

* 对于非持久性客户端，消息直接发布给订阅的客户端。

* 持久性客户端维护一个会话状态，该状态在各个连接之外持续存在，允许它们在离线时接收消息。这种持久性使 TBMQ 能够确保在客户端重新连接后向其传递消息。因此，针对此类客户端的消息处理采用了不同的方法。
但是，**请注意**，如果订阅客户端既是持久性的，又以服务质量 (QoS) 级别 _0_（_AT_MOST_ONCE_）订阅，则与该订阅关联的所有消息都将传递给客户端，无需任何补充步骤。对于 QoS 级别高于 0 的持久性订阅者也是如此，只要发布者以 QoS 级别 0 传输消息即可。这种行为是由于 QoS 级别降级而实现的。

通过利用 Kafka 作为中间消息存储并根据客户端特征采用不同的处理策略，TBMQ 优化了消息传递并确保了在持久性和非持久性客户端场景中进行可靠的通信。

### 设备客户端

**DEVICE** 类型的客户端可以表现出持久性或非持久性行为，具体取决于 _CONNECT_ 数据包中指定的设置，如 [客户端持久性](#client-persistence) 部分所述。在有持久性设备客户端的情况下，相关消息将被定向到另一个称为 `tbmq.msg.persisted` 的 Kafka 主题。

为了便于将消息传递给在线和离线客户端，一个专用的 Kafka 消费者会勤奋地轮询 `tbmq.msg.persisted` 主题中的消息。然后处理这些消息并将其持久化到 **PostgreSQL** 数据库中，然后再分发给订阅的在线客户端。这种方法确保在线和离线客户端都可以接收所有消息，从而保证在不同客户端状态下消息传递的一致性。

当离线客户端重新连接到代理时，它们会收到在其离线期间存储的持久性消息。可以通过修改 `MQTT_PERSISTENT_SESSION_DEVICE_PERSISTED_MESSAGES_LIMIT` 环境变量来控制离线客户端在重新连接时收到的消息数量。这使得能够微调离线客户端的消息检索行为，允许自定义处理它们在重新连接时收到的消息数量。

### 应用程序客户端

**APPLICATION 类型的客户端是专有持久性的。**

如果客户端被认证为 APPLICATION 类型但不是持久性的，则发往该客户端的消息将直接发送，而无需经历额外的持久性步骤。为了提醒非持久性应用程序客户端的影响，客户端会话详细信息页面上会突出显示一条警告消息。

{% include images-gallery.html imageCollection="mqtt-client-type" %}

轮询 `tbmq.msg.all` Kafka 主题中的消息后，这些消息随后被转发到一个专用的 Kafka 主题。对于每个连接的应用程序客户端，都会自动创建一个单独的 Kafka 主题。此主题的命名约定遵循以下格式：

```
tbmq.msg.app.$CLIENT_ID
```

其中 **$CLIENT_ID** 表示与连接客户端关联的唯一客户端 ID。

**重要提示：**如果客户端 ID 包含除字母数字字符之外的其他字符，则将使用从客户端 ID 派生的哈希值来构建主题。这确保了兼容性和遵守主题命名约定，因为某些特殊字符可能不被允许或在主题名称中不受支持。通过从客户端 ID 生成哈希，可以有效地处理任何不兼容或禁止的字符，从而确保正确的主题构建和功能。

```
tbmq.msg.app.$CLIENT_ID_HASH
```

当客户端 ID 包含特殊字符时，使用哈希构建主题的行为由 `TB_APP_PERSISTED_MSG_CLIENT_ID_VALIDATION` 环境变量控制。默认情况下，此变量处于启用状态，这意味着验证过程处于活动状态，确保正确创建主题。但是，如果您选择通过将变量设置为 _false_ 来禁用此验证，则系统将不再为客户端 ID 中包含特殊字符的客户端创建 Kafka 主题，从而导致无法创建相应的主题。在配置环境和处理具有特殊字符的客户端 ID 时，这一点很重要。

为了确保高效的处理和最佳性能，一个独立的 Kafka 消费者会持续轮询上述主题中的消息。此消费者负责将消息传递给相应的应用程序客户端。通过在单独的线程中处理每个应用程序客户端，这种方法能够提高性能并简化消息传递。